1.对web标准以及w3c的理解
 web标准简单来说可以分为结构、表现和行为。其中结构主要就是由HTML标签组成；表现指的是css样式表，通过css可以使页面的结构标签更具美感；行为指的是页面和用户具有一定的交互，同时页面结构或者表现发生变化，主要是由js 组成。
  web标准一般是将该三部分独立分开，使其更具有模块化。
  w3c对web标准提出了规范化的要求，也就是在实际变成中的一些代码规范：
  1）对结构要求：
    - 标签字母要小写
    - 标签要闭合
    - 标签不允许随意嵌套
  2） 对css和js来说：
    - 尽量使用外链css样式和js脚本。使结构、标签和行为分为三块，复合孤帆。同时提高页面渲染速度，提高用户体验 。
    - 样式尽量少ongoing行间样式表，使结构和表现分离，标签的id和class等属性名要做到见文知义，标签越少，加载越快，用户体验提高，代码维护简单，便于修改。
///////////////////////////////////////////////////////////////////
2.浏览器内核的差异及兼容问题
  浏览器最重要也就是最核心的部分就是Rendering Engine,大概翻译为“解释引擎”,也就是浏览器内核。负责对网页语法的解释(html,js),并渲染网页。所以通常说 浏览器的内核也就是指浏览器所采用的渲染引擎，渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。不同的浏览器内核对网页编写语法的解释也有不同，因此同一网页在不同内核的浏览器里渲染的效果也可能不一样
  - Trident： IE浏览器使用的内核
  - Gecko：Mozilla FireFox (火狐浏览器) 采用了该内核
  - Presto： 目前Opera采用的内核
  - Webkit：苹果公司自己的内核
  兼容问题：
  - 不同浏览器的标签默认的外补丁和内补丁不同
    问题症状：随便写几个标签，不加样式控制的情况下，各自的margin 和padding差异较大。
    碰到频率:100%
    解决方案：CSS里    *{margin:0;padding:0;}
  - 浏览器兼容问题二：块属性标签float后，又有横行的margin情况下，在IE6显示margin比设置的大
    问题症状：随便写几个标签，不加样式控制的情况下，各自的margin 和padding差异较大。
    碰到频率:100%
    解决方案：CSS里    *{margin:0;padding:0;}
  - 浏览器兼容问题三：设置较小高度标签（一般小于10px），在IE6，IE7，遨游中高度超出自己设置高度
    问题症状：IE6、7和遨游里这个标签的高度不受控制，超出自己设置的高度
    碰到频率：60%
    解决方案：给超出高度的标签设置overflow:hidden;或者设置行高line-height 小于你设置的高度。
  - 浏览器兼容问题四：行内属性标签，设置display:block后采用float布局，又有横行的margin的情况，IE6间距bug
    问题症状：IE6里的间距比超过设置的间距
    碰到几率：20%
    解决方案：在display:block;后面加入display:inline;display:table;
  - 浏览器兼容问题五：图片默认有间距
    问题症状：几个img标签放在一起的时候，有些浏览器会有默认的间距，加了问题一中提到的通配符也不起作用。
    碰到几率：20%
    解决方案：使用float属性为img布局
  - 浏览器兼容问题六：标签最低高度设置min-height不兼容
    问题症状：因为min-height本身就是一个不兼容的CSS属性，所以设置min-height时不能很好的被各个浏览器兼容
    碰到几率：5%
    解决方案：如果我们要设置一个标签的最小高度200px，需要进行的设置为：{min-height:200px; height:auto !important; height:200px; overflow:visible;}
  - 浏览器兼容问题七：透明度的兼容CSS设置
    做兼容页面的方法是：每写一小段代码（布局中的一行或者一块）我们都要在不同的浏览器中看是否兼容，当然熟练到一定的程度就没这么麻烦了。建议经常会碰到兼容性问题的新手使用。很多兼容性问题都是因为浏览器对标签的默认属性解析不同造成的，只要我们稍加设置都能轻松地解决这些兼容问题。如果我们熟悉标签的默认属性的话，就能很好的理解为什么会出现兼容问题以及怎么去解决这些兼容问题。
    /* CSS hack*/
///////////////////////////////////////////////////////////////////////
3.css的布局
     五种基本布局定位类型:
     * 弹性布局 - 总体宽度及其中所有栏的值都以 em 单位编写。这应使布局能够使用浏览器的指定基本字体大小缩放。 对于视力不好的用户, 这可能更有吸引力、更易于访问, 因为栏宽度将变得更宽 , 能以任何大小显示更舒适、更可读的行长度。 由于总体宽度将缩放, 您的设计必须允许可这宽度。
* 固定布局 - 总体宽度及其中所有栏的值都以像素单位编写。 布局位于用户浏览器的中心。
* 流体布局 - 总体宽度及其中所有栏的值都以百分比编写。 百分比通过用户浏览器窗口的大小计算。
* 混合布局 - 混合布局组合两种其他类型的布局 - 弹性和流体。 页面的总宽度为 100%, 但侧栏值设置为 em 单位。
* 绝对定位布局 - 所有前述布局的外栏使用浮动内容。 而绝对定位布局完全如其名所示 - 有绝对定位的外栏。 必须记住, 当使用这些布局时, 侧栏会“提出文档流程”, 因而可能有一些不合适的结果 (例如, 页脚可能“看不见”在侧栏在何处结束并在主要内容区域包含的内容少于侧栏的页面与页脚重叠)。
/////////////////////////////////////////////////////////////////////////
4.css的盒模型
所有HTML元素可以看作盒子，在CSS中，"box model"这一术语是用来设计和布局时使用。
CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。
盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。
////////////////////////////////////////////////////////////////////
5.css的选择器优先级
  当两个规则都作用到了同一个html元素上时，如果定义的属性有冲突，那么应该用谁的值的，CSS有一套优先级的定义。
  不同级别：
  在属性后面使用 !important 会覆盖页面内任何位置定义的元素样式。
  作为style属性写在元素内的样式
  id选择器
  类选择器
  标签选择器
  通配符选择器
  浏览器自定义或继承
        总结排序：!important > 行内样式>ID选择器 > 类选择器 > 标签 > 通配符 > 继承 > 浏览器默认属性

  同一级别：
  同一级别中后写的会覆盖先写的样式
///////////////////////////////////////////////////////////////////////////
6.css选择器有哪些？有哪些新特性？有哪些伪类？
  1）- 标签选择器：通过标签名称来给元素加css样式属性 p{} 权重1
     - 类选择器：也叫class选择器 通过标签的类名来选择元素  .box{} 权重10
     - *通配符选择器：也叫全局选择器，选择所有的html元素，用来清除浏览器默认样式 *{} 权重 ： 1>*>0
     - id选择器 通过标签的id名来选html元素  权重100
     - 后代选择器 ：也叫派生选择器。在一个根元素的范围内，查找他的后代元素 语法：祖辈选择器（空格）要查找的后代选择器{} 权重：选择器之和.选择器在解析的时候是从右往左解析的  eg: ul li a{} 先找页面中所有的a元素 再筛选哪些a是在li下面的。。。
     - 属性选择器以下
     - 基本属性选择器：使用元素的标签属性来选择html元素 语法：[标签属性名]{} // [标签属性名=属性值]{} 利用标签的属性名和属性值来选择html元素  权重10
     - 分组选择器（并集选择器） 语法：选择器1，选择器2，选择器3{} 权重 独立计算不叠加计算
     - 交集选择器  权重 选择器之和
     - 子级选择器  存在包含关系的元素选择，通过父级确定选择子级 语法：父级选择器>子级选择器{} css样式在子级身上起作用，父级元素是用来确定范围的 权重 选择器之和
     - 相邻兄弟选择器  语法：哥哥选择器+弟弟选择器{} 通过哥哥来选择紧挨着的弟弟元素 权重 选择器相加之和
     -选择同级弟弟元素 通过哥哥选择弟弟元素 语法：哥哥选择器~弟弟选择器{} 权重 选择器之和
 2）伪类选择器
     - ：before 会在设置的元素所有内容开始之前
     - ：after  会在设置的元素所有内容结束之后
     - {content:""} “设置内容”
   动态伪类选择器
   hover： 最初只能用在超链接和表单元素身上，后来可以使用在所有的元素身上
///////////////////////////////////////////////////////////////////////
7.清除浮动的几种方法 ，优缺点？
1)  添加新的元素 、应用 clear：both；加一个clear标签  <div id="clear"></div>
             #clear{
                      clear: both;
                      height:0;
                      line-height: 0;
                      font-size: 0;
                  }
2） 给父级元素请浮动
      父级div定义 overflow: auto
       #outer{
                  overflow: hidden; // 或者auto
                  zoom:1;  /*zoom:1 是用来处理兼容性问题*/
              }
3):after 方法：（注意：作用于浮动元素的父亲）
       #outer:after{
                clear:both;
                content: '';
                display:block;
                width: 0;
                height: 0;
                visibility:hidden;
            }
   其中clear:both;指清除所有浮动；content: '.'; display:block;对于FF/chrome/opera/IE8不能缺少，其中content（）可以取值也可以为空。visibility:hidden;的作用是允许浏览器渲染它，但是不显示出来，这样才能实现清楚浮动。
////////////////////////////////////////////////////////////////////////
8.图片如何实现垂直居中
  1)方法一：
  给父级元素div 的display：table;  text-align: center; 然后给img标签外部套一个span  给span 设置display: table-cell;vertical-align: middle;
  2)方法二：
  通过position定位来实现。将div设置成相对定位relative，将img设置成绝对定位absolute，left:50%，top:50%，此时图片的左上角位于div的中心，要是图片的中心位于div的中心，就需要将图片向上移动图片高度的一半，并向左移动图片宽度的一半。
////////////////////////////////////////////////////////////////////////
9.css hack指的是什么？
   CSS hack由于不同厂商的浏览器，比如Internet Explorer,Safari,Mozilla Firefox,Chrome等，或者是同一厂商的浏览器的不同版本，如IE6和IE7，对CSS的解析认识不完全一样，因此会导致生成的页面效果不一样，得不到我们所需要的页面效果。 这个时候我们就需要针对不同的浏览器去写不同的CSS，让它能够同时兼容不同的浏览器，能在不同的浏览器中也能得到我们想要的页面效果。
   简单的说，CSS hack的目的就是使你的CSS代码兼容不同的浏览器。当然，我们也可以反过来利用CSS hack为不同版本的浏览器定制编写不同的CSS效果。
   CSS Hack大致有3种表现形式，CSS类内部Hack、选择器Hack以及HTML头部引用(if IE)Hack，CSS Hack主要针对类内部Hack：比如 IE6能识别下划线"_"和星号" * "，IE7能识别星号" * "，但不能识别下划线"_"，而firefox两个都不能认识。等等
   选择器Hack：比如 IE6能识别*html .class{}，IE7能识别*+html .class{}或者*:first-child+html .class{}。等等
   HTML头部引用(if IE)Hack：针对所有IE：<!--[if IE]><!--您的代码--><![endif]-->，针对IE6及以下版本：<!--[if lt IE 7]><!--您的代码--><![endif]-->，这类Hack不仅对CSS生效，对写在判断语句里面的所有代码都会生效。书写顺序，一般是将识别能力强的浏览器的CSS写在后面
   2）常用的css hack方式：
   （1）方式一 条件注释法
   只在IE下生效
   <!--[if IE]>
   这段文字只在IE浏览器显示
   <![endif]-->
   只在IE6下生效
   <!--[if IE 6]>
   这段文字只在IE6浏览器显示
   <![endif]-->
   只在IE6以上版本生效
   <!--[if gte IE 6]>
   这段文字只在IE6以上(包括)版本IE浏览器显示
   <![endif]-->
   只在IE8上不生效
   <!--[if ! IE 8]>
   这段文字在非IE8浏览器显示
   <![endif]-->
   非IE浏览器生效
   <!--[if !IE]>
   这段文字只在非IE浏览器显示
   <![endif]-->
   （2）方式二 类内属性前缀法
   属性前缀法是在CSS样式属性名前加上一些只有特定浏览器才能识别的hack前缀，以达到预期的页面展现效果。
   IE浏览器各版本 CSS hack 对照表
   说明：在标准模式中
   “-″减号是IE6专有的hack
   “\9″ IE6/IE7/IE8/IE9/IE10都生效
   “\0″ IE8/IE9/IE10都生效，是IE8/9/10的hack
   “\9\0″ 只对IE9/IE10生效，是IE9/10的hack
   （3）CSS hack方式三：选择器前缀法
   选择器前缀法是针对一些页面表现不一致或者需要特殊对待的浏览器，在CSS选择器前加上一些只有某些特定浏览器才能识别的前缀进行hack。
   目前最常见的是
   *html *前缀只对IE6生效*+html *+前缀只对IE7生效@media screen\9{...}只对IE6/7生效@media \0screen {body { background: red; }}只对IE8有效@media \0screen\,screen\9{body { background: blue; }}只对IE6/7/8有效@media screen\0 {body { background: green; }} 只对IE8/9/10有效@media screen and (min-width:0\0) {body { background: gray; }} 只对IE9/10有效@media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) {body { background: orange; }} 只对IE10有效等等
///////////////////////////////////////////////////////////////////////
10.css盒模型的认识
1）标准模型和ie模型的区别
  标准模型：盒子模型的范围包括 margin、border、padding、content（中间内容），并且 content 部分不包含其他部分。
  ie模型：包括 margin、border、padding、content，和标准 W3C 盒子模型不同的是：IE 盒子模型的 content 部分包含了 border 和 pading。
2）css中如何设置盒模型的？
   浏览器默认的方式是`content-box(标准模型 )`，通过改变样式`box-sizing`来切换`content-box(标准模型)`和`border-sizing(IE模型)`
 <style type="text/css">
 6         #box {
 7             width: 300px;
 8             height: 300px;
 9             border: 1px solid #000;
10         }
11     </style>
12 </head>
13 <body>
14 <div id="box"></div>
3)JS如何设置和获取盒模型对应的宽和高?
    let box=document.getElementById('box');
    let width=document.getElementById('box').style.width;
   console.log(width); //此方法只能获取行内内嵌式的样式。style="width:300px"
//////////////////////////////////////////////////////////////////////
11.什么是优雅降级和渐进增强?

   渐进增强 progressive enhancement：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。
    优雅降级 graceful degradation：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。
    区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。
///////////////////////////////////////////////////////////////////////
12.什么是BFC？
  BFC：Box、Formatting Context
  BFC(Block formatting context)直译为"块级格式化上下文"。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。
    Box 是 CSS 布局的对象和基本单位， 直观点来说，就是一个页面是由很多个 Box 组成的。元素的类型和 display 属性，决定了这个 Box 的类型。 不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此Box内的元素会以不同的方式渲染。让我们看看有哪些盒子：

block-level box:display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block fomatting context；
inline-level box:display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。并且参与 inline formatting context；
run-in box: css3 中才有， 这儿先不讲了。
　　Formatting context

　　Formatting context 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的 Formatting context 有 Block fomatting context (简称BFC)和 Inline formatting context (简称IFC)。
//////////////////////////////////////////////////////////////////////
13.如何创建BFC?








//////////////////////////////////////////////////////////////////////
14.BFC使用场景?

